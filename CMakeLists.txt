cmake_minimum_required(VERSION 3.8)
#
# Here we check whether frozen is being configured in isolation or as a component
# of a larger proeject. To do so, we query whether the `PROJECT_NAME` CMake
# variable has been defined. In the case it has, we can conclude frozen is a
# subproject.
#
# This convention has been borrowed from the Catch C++ unit testing library.
#
if( DEFINED PROJECT_NAME )
  set( subproject ON )
else()
  set( subproject OFF )
endif()

project(frozen VERSION 1.0.0 LANGUAGES CXX)
include(CTest)
include(CMakeDependentOption)

#
# The `frozen.testing`, `frozen.benchmark`, and `frozen.coverage` options 
# only appear as cmake-gui and ccmake options iff frozen is the highest 
# level project. In the case that frozen is a subproject, these options are 
# hidden from the user interface and set to `OFF`
#
CMAKE_DEPENDENT_OPTION(frozen.tests
  "Build the frozen tests and integrate with ctest"
  ${BUILD_TESTING} "NOT subproject" OFF)

CMAKE_DEPENDENT_OPTION(frozen.benchmark
  "Build the frozen benchmark"
  OFF "NOT subproject" OFF)

CMAKE_DEPENDENT_OPTION(frozen.coverage
  "Enable test coverage collection of frozen tests"
  OFF "NOT subproject" OFF)

#
# frozen has no compiled components. As such, we declare it as an `INTERFACE`
# library, which denotes a collection of target properties to be applied
# transitively to linking targets. In our case, this amounts to an include
# directory and project header files.
#
add_library(frozen INTERFACE)
add_library(frozen::frozen ALIAS frozen)

#
# frozen requires C++ 14 support, at a minimum. Setting the `cxx_std_14` compile
# features ensures that the corresponding C++ standard flag is populated in
# targets linking to frozen
#
target_compile_features(frozen INTERFACE cxx_std_14)

#
# The include directory for frozen can be expected to vary between build
# and installaion. Here we use a CMake generator expression to dispatch
# on how the configuration under which this library is being consumed.
#
target_include_directories(frozen INTERFACE
  $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/include>
  $<INSTALL_INTERFACE:include>)

add_subdirectory(include/frozen)

if(frozen.tests)
  add_subdirectory(tests)
  add_subdirectory(examples)
endif()

if(frozen.benchmark)
  add_subdirectory(benchmarks)
endif()

include(CMakePackageConfigHelpers) # provides `write_basic_package_version_file`

#
# As a header-only library, there are no target components to be installed
# directly (the PUBLIC_HEADER property is not white listed for INTERFACE
# targets for some reason).
#
# However, it is worthwhile export our target description in order to later
# generate a CMake configuration file for consumption by CMake's `find_package`
# intrinsic
#
install(TARGETS frozen EXPORT frozenConfig)

#
# Non-testing header files (preserving relative paths) are installed to the
# `include` subdirectory of the `$INSTALL_DIR/${CMAKE_INSTALL_PREFIX}`
# directory. Source file permissions preserved.
#
install(DIRECTORY include/
  DESTINATION include
  USE_SOURCE_PERMISSIONS
  FILES_MATCHING PATTERN "*.h")

#
# As a header-only library, there are no target components to be installed
# directly (the PUBLIC_HEADER property is not white listed for INTERFACE
# targets for some reason).
#
# However, it is worthwhile export our target description in order to later
# generate a CMake configuration file for consumption by CMake's `find_package`
# intrinsic
#
write_basic_package_version_file("frozenConfigVersion.cmake"
  VERSION ${frozen_VERSION}
  COMPATIBILITY SameMajorVersion)

install(FILES "${CMAKE_CURRENT_BINARY_DIR}/frozenConfigVersion.cmake"
  DESTINATION share/cmake/frozen
  PERMISSIONS OWNER_READ GROUP_READ)

install(EXPORT frozenConfig
  FILE frozenConfig.cmake
  NAMESPACE frozen::
  DESTINATION share/cmake/frozen
  PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)

#
# Rudimentary CPack support.
#
# CPack provides a mechanism to generate installation packaging for a project,
# e.g., self-extracting shell scripts, compressed tarballs, Debian Package files,
# RPM Package Manager files, Windows NSIS installation wizards,
# Apple Disk Images (.dmg), etc.
#
# Any system libraries required (runtimes, threading, etc) should be bundled
# with the project for this type of installation. The
# `InstallRequiredSystemLibraries` CMake module attempts to provide this
# functionality in an automated way. Additional libraries may be specified as
#
# ```cmake
# list(APPEND CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS <library>)
# ```
#
# A packaged installation can be generated by calling
#
# ```sh
# cpack -G <packaging type> --config CPackConfig.cmake
# ```
#
# See `cpack --help` or the CPack documentation for more information.
#
include( InstallRequiredSystemLibraries )
set( CPACK_PACKAGE_VENDOR "Quarkslab" )
set( CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE" )
set( CMAKE_PROJECT_HOMEPAGE_URL "https://blog.quarkslab.com/frozen-an-header-only-constexpr-alternative-to-gperf-for-c14-users.html" )
include( CPack )
